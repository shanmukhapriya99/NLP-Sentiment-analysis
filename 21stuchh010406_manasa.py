# -*- coding: utf-8 -*-
"""21stuchh010406-manasa

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BUpjhXc1F0E0UsZ1qe0eR3lcHYeS97vp

# Using Jupyter Notebooks
"""

!pip install nltk spacy gensim pandas scikit-learn

"""##Introduction
Jupyter notebooks is an open-source web-based Python editor which runs in your browser. It allows a combination of text written in a html-like format known as "markdown", such as the block of text you're reading right now, and inline code, tools and outputs such as this one:
"""

import nltk
# nltk is natural language toolkit widely use in language processing, text processing, corpora, sentiment analysis
nltk.download('punkt') # Download the Punkt tokenizer
#punkt is a unsupervised machine learning algorithm for tokenizing text
from nltk.tokenize import word_tokenize
#word_tokenize is a pert of NLTK that splits text into individual words

sentence = "Hello, world! This is NLP."
tokens = word_tokenize(sentence)
print(tokens) # Output: ['Hello', ',', 'world', '!', 'This', 'is','NLP', '.']





import nltk
nltk.download('punkt') # Download the Punkt tokenizer
from nltk.tokenize import word_tokenize

from nltk.corpus import stopwords
# stopwords are comman words that do not carry significant meaning in a text,
# it reduces noise in the data
nltk.download('stopwords')
stop_words = set(stopwords.words('english'))
filtered_tokens = [word for word in tokens if word.lower() not in
stop_words]
print(filtered_tokens)
# filtered tokens are the resulting tokens after removing stopwords, punctuation, unwanted characters from original text

from nltk.stem import PorterStemmer
from nltk.stem import WordNetLemmatizer
# NLTK stemming is a process to reduce words to their base or root form,
# it as modules like PORTERSTEMMER, WORDNETLEMMATIER
nltk.download('wordnet')
# WORDNET is a large lexical database of english words,
# improves text understanding
ps = PorterStemmer()
lemmatizer = WordNetLemmatizer()
print(ps.stem("faster")) # Output: run
print(lemmatizer.lemmatize("faster")) # Output: running (more context needed for lemmatization)

import pandas as pd
# pandas used for manuplation and analysis
import nltk
from sklearn.model_selection import train_test_split
# splits the dataset into training and test sets
from sklearn.feature_extraction.text import CountVectorizer
# CountVectorizer is a text preprocessing technique commonly used in
# natural language processing (NLP) tasks for converting a collection of
#  text documents into a numerical representation.
from sklearn.naive_bayes import MultinomialNB
from sklearn import metrics

data = {
 'text': [
 'I love this movie!',
 'This was a terrible movie.',
 'I really enjoyed the film.',
 'Worst experience ever.',
 'It was fantastic!',
 'Not worth the time.',
 'Absolutely amazing!',
 'It was okay, not great.',
 'I hate this film.',
 'Best movie ever!'
 ],
 'sentiment': [
 'negative',
 'positive',
 'negative',
 'positive',
 'negative',
 'positive',
 'negative',
 'neutral',
 'negative',
 'positive'
 ]
}

df = pd.DataFrame(data)
# pandas DataFrame is a way to represent and work with tabular data

print(df)

X = df['text']
y = df['sentiment']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2,
random_state=42)
# Vectorize the text
vectorizer = CountVectorizer()
X_train_vectorized = vectorizer.fit_transform(X_train)
#  to fit the data into a model and transform it into a form that
#  is more suitable for the model in a single step.
X_test_vectorized = vectorizer.transform(X_test)

model = MultinomialNB()
#  classifier to calculate the probability distribution of text data
model.fit(X_train_vectorized, y_train)

y_pred = model.predict(X_test_vectorized)
# passes the input vector through the model and returns the output tensor for each datapoint.

accuracy = metrics.accuracy_score(y_test, y_pred)
# calculates the accuracy score for a set of predicted labels against the true labels.
confusion_matrix = metrics.confusion_matrix(y_test, y_pred)
# an intuitive table that lets us see the detailed classification results of an algorithm
print(f'Accuracy: {accuracy:.2f}')
print('Confusion Matrix:')
print(confusion_matrix)

def predict_sentiment(text):
 text_vectorized = vectorizer.transform([text])
 # It is used to transform a given text into a vector on the basis
 #  of the frequency (count) of each word that occurs in the entire text.
 prediction = model.predict(text_vectorized)
 return prediction[0]
# Example usage
new_text = "I loved the plot and the acting!"
print(f'Sentiment: {predict_sentiment(new_text)}')





print("Hello World")

"""This combination allows for the procution of beautiful documents containing software, documentation and discussion. For larger codes you may wish to use Python in a stand-alone environment such as a traditional IDE. But for demonstration purposes Jupyter is a very useful tool.

Notebook files have the extension ".ipynb" extension. A Jupyter notebook is one of many environments you may run Python code.  Colab and the Jupyter notebook editor in Anaconda are two of the many pieces of software you may use to write and run a Jupyter notebook. For this course we recommend using the online Google Colab tool, but you can use Anaconda to run the notebooks on your own machine within an internet connection. On college computers, Jupyter can be used by launchng Anaconda from the Software Hub Apps Anywhere interface.

Note that exact interfaces will differ between different environments but the same functionality should be found in most environments. This course will be using the Colab environment.

## Cells and Executing Code

A notebooks is made up of one or more "cells". Cells can contain the html-like text used to generate text or code to be run by the user. A cell containing a piece of code may be recognised by the the  ```[]```  to the left of it. Code in these blocks can be run in a nubmer of ways. The simplest is click on the ```[ ]``` . This will execute the code. Try this with the code snippet below:
"""

print("Yes, it worked!")

"""You should have seen the message "Yes, it worked!" appear immediately beneath the code. This is the output of the code, which has been printed to the screen. You may also have noticed a number appear between the square brackets to the left of the code snippet. This indicates the order in which the code snippet has been executed. Code cells may be executed in any order and variables will be saved between execution of code snippets. To try this, execute the three codes snippets below in the following order:
- 1
- 2
- 3
- 2
"""

a="Message 1"

print(a)

a="Message 2"

"""The first time you ran code snippet 1 you should have seen "Message 1" as the output and the second time the output should have been "Message 2". This is because the first time it was run, the value assigned to the variable named "a" was "Message" as set by the first code snippet and the second time it was "Message 2" as set by the third code snippet. Note also the current numbers contained within square brackets. These help you to kno which cells have been executed and in which order.

##Sharing Jupyter Notebooks on Colab
When a Jupyter Notebook is shared with you on Colab, you will often receive access to the notebook which will alow you to run code, but not edit it. This should be the case for the notebooks that form part of this course. In this case you can select "Save a Copy in Drive" from the "File" menu to create a new copy that is yours and yo can edit.

For this course, it is reccommended that you create two copies. One of these should be the original copy without your edits, and another which you can edit to compelte exercises or expierment.

## Basic Jupyter Commands

Jupyter contains a number of useful tools for executing these cells. By using the "Runtime" menu, you can run multiple cells at a time using "Run all", "Run before", "Run selected" and "Run after".

You can clear output (this is the term for what is written under a code cell when it's executed) by clicking on the symbol to the left of it. You can clear all outputs from the notebook using the "Clear All Outputs" command on the "Edit" menu. Clearing the output will not unset variables set by the code snippets run, only remove the output printed to the screen.

To unset variables, use the "Restart Runtime" or "Reset Runtime" option in the Runtime menu. The "Interrupt Execution" command on the kernel menu will halt the procesing of code, which can be useful if you've accidentally written a piece of code that will never finish executing or if the code is taking too long to execute.

The "insert" menu allows you to create new cells. The "cell type" option in the "cell" menu allows you toggle the current cell type between the different cell types available:
- **Code**: Code snippets
- **Text**: The html-like language used to generate text, tables, equations, etc.

Alternatively, you can hover your mouse in the space after a cell and add a code or text cell there.

###Exercise

Try each of these commands from the different menus for yourself on this  notebook and ensure they behave as you would expect.

## Text Cells in Jupyter
You can include all sort so information in Jupyter text cells to obtain different effects. To see how each of the following examples is generated, double click on this cell. To return to the formatted text, run the cell.

### Headings
Headings can be generated using the hash symbol "#". The more of these there are, the smaller the heading. The sub-sub-heading above is an example.

### Tables
Tables can be created in a way similar to basic html, using the a comabination of the "|" and "-" symbols:

| This | is    |
|------|-------|
|   a  |  table|
| It's | fancy |

### Equations
Equations can be written in a way similar to LaTeX by surrouding the text with "\$" symbols:

$a=\frac{\int\limits_{0}^{\pi} \sin{(bx)} \textrm{d}x}{4}$

Don't worry if you don't understand the exact syntax used to generate this example. In your example of it in your exercise, try writing something very simple instead. If it looks like a simple algebraic expression, it will probably render how you intend.

### Code Snippets
You can write snippets of code in a text cell and they will be highlighted as if they were code written in a code cell. This can be useful for demonstrating a code feature in a textual way. For example:

```python
print ("Hello World")
```

There is not a way to run this code, it is merely normal text highlighted to look like code. The "python" which precedes the code itself tells Jupyter which language you are writing the code snippet in so it can be highlighted accorindly.

In some environments, text cells may also be referred to as "markdown" cells.

###Exercise
Try creating simple versions of each of the constructs above in a new text cell below this one.
"""